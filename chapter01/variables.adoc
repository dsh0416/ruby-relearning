=== 变量与基本算数

==== 整数运算

既然计算机叫计算机，那么我们还是从「计算」作为入门的第一步吧。

四则运算在 Ruby 语言中的表达几乎和现实世界算数的表达式一样。小小的不同是，由于乘法 `×` 和除法的符号 `÷` 在键盘上不方便输入，于是使用了另两个符号 `*` 和 `/` 来替代乘和除。

[WARNING]
.特别注意
====
除法符号是 `/` 不是 `\`。
====

[source,ruby]
----
1 + 1 # => 2
1 - 5 # => -4
3 * 7 # => 21
6 / 2 # => 3
----

需要注意的是，整数之间的加减乘除的结果必然还是整数。如下面的代码所见，整数间的除法运算实际上是整除。

[source,ruby]
----
5 / 2 # => 2
----

如果需要获得整除后的余数，Ruby 提供了模除运算 `%`：

[source,ruby]
----
5 % 2 # => 1
----

需要特别注意的是，在 Ruby 中对负数取余数的结果可能和其它语言不一样。Ruby 中余数的符号 **永远和除数一致**。

[source,ruby]
----
5 % 2 # => 1
-5 % 2 # => 1

5 % -2 # => -1
-5 % -2 # => -1
----

这一设计带来了显而易见的好处，在判断一个数字是不是奇数的时候我们只需要 `% 2` 检查结果是否为 `1` 即可。而无需确认其正负。但坏处也是很明显的，如果你尝试从其它编程语言移植程序到 Ruby 上需要格外小心对正负数取模的处理。

Ruby 的整数没有无穷大和未定形式，如果整数除以零会直接抛出程序错误。如果没有处理错误，在程序运行中会直接退出。

[source,ruby]
----
3 / 0 # => ZeroDivisionError (divided by 0)
----

Ruby 另一个特色是大整数运算。不同于 C、C++ 语言中整数类型拥有固定的内存分配大小（上限和下限），Ruby 的整数类型的大小是会动态调整的。这使得你可以自由处理非常大的数字而无需考虑溢出问题。

例如 C++ 语言中的下面代码：

[source,c++]
----
#include <iostream>

int main() {
  std::cout << 10000000000000000000 * 10000000000000000000 << std::endl;
  return 0;
}
----

会因为内存溢出，给出一个不符合数学常识的 `687399551400673280` 结果。而在 Ruby 中你完全不用担心这一点。

[source,ruby]
----
10000000000000000000 * 10000000000000000000 # => 100000000000000000000000000000000000000
----

这一特性在幂运算时特别实用。Ruby 的幂运算符号是 `+**+`。`+a**b+` 相当于 latexmath:[a^b]。

[source,ruby]
----
2**256 # => 115792089237316195423570985008687907853269984665640564039457584007913129639936
----

==== 局部变量

变量 (variable) 是程序开发的基础概念之一。变量是一种对临时存储的抽象概念。Ruby 中的变量有 4 种类型：

- 局部变量 `variable`
- 实例变量 `@variable`
- 类变量 `@@variable`
- 全局变量 `$variable`

这里所介绍的变量是局部变量，至于其它变量的时候，我们会在之后章节中再做介绍。

Ruby 的局部变量以小写字母或下划线 `_` 开头。Ruby 中的 `=` 符号和数学中的等于不同，表示「赋值」符号。表示将 `=` 符号 **右边** 的结果保存到 **左边** 的变量里。数学中等号两边内容可以互换，但在赋值中是 **绝对** 不能的。

在 irb 中试一下下面的代码，来理解局部变量和 `=` 的使用。

[source,ruby]
----
a = 1
a + 1 # => 2
a + 3 # => 4
a = 2
a + 1 # => 3
a + 3 # => 5
2 = a # SyntaxError
----

===== 试一试

- 创建两个变量 `a` 和 `b`，给它们赋两个整数，计算并打印它们的和。
- 创建两个变量 `a` 和 `b`，给它们赋两个整数，计算并打印它们的积。
- 创建三个变量 `a` 和 `b` 和 `c`，给 `a` 和 `b` 赋两个整数，计算它们的和，将它们的结果写入 `c` 变量中。

**答案见《附录三：参考答案》中的 局部变量 小节**

==== Ruby 的类型系统

类型系统自古以来都是高级语言的一个非常重要的属性。所谓类型，指的是程序语言中变量、常量的数据类型，类型是对数据的约束。比如我们可以检查这一变量是数字还是字符串，从而避免超出我们预料的行为。

基于不同的分类方法可以把不同语言的类型系统分成不同类别。一般我们会说 Ruby 的类型系统是一个动态类型、强类型系统。其中动态类型与静态类型相对，而强类型与弱类型相对。类型的动态与静态、强与弱是一对正交（orthogonal）的概念。

image::type-system-example.png[Type System Example]

理解这一问题，我们先要理解类型可能的错误，以及错误带来的问题。

一类问题是出现在类似于 C 语言中的内存管理带来的错误。比如说根据某一变量的类型分配了一定空间，但是在写入的时候，占用了大于既定的空间。C 语言不会检查这一类的错误，从而造成程序写入到了其它变量 / 程序本来占用着的空间，进而产生完全未知的行为。这一问题称为「缓冲区溢出」，这会带来未知的程序错误，同时还有可能被黑客巧妙利用从而进一步攻击你的程序。一个典型的案例是 SONY 在 PSP-3000 游戏机上的相册应用存在一个「缓冲区溢出」漏洞，通过一张特殊的图片，黑客实现了对 PSP-3000 的破解，从而运行黑客指定的第三方程序。

另一类问题则是由隐式类型转换带来的问题。这一类问题的翘楚就是 PHP 和 JavaScript。这两门语言在运算所需类型不满足的情况下，比起抛出错误，更愿意尝试一系列自动的类型转换来满足需求，而这一过程会带来一系列的问题。

比如在 PHP 中著名的 Type Juggling 漏洞，使用 `==` 符号比较两个完全不同的字符串：

[source,php]
----
if ('0e1234' == '0e5678') {
  echo('wat');
}
----

程序会返回 `wat`，纵使字符串 `0e1234` 和 `0e5678` 完全不相同，但是 PHP 发现了这些字符串都是 `0e` 开始的，于是会认为这 **可能** 是 https://zh.wikipedia.org/wiki/%E7%A7%91%E5%AD%A6%E8%AE%B0%E6%95%B0%E6%B3%95[科学记数法] 的数字。而无论 0 的多少次方都是 0，所以两者都是 0，因此认为这两个字符串相等。这显然不是预期行为。这一方法常会在一些特殊情况引发更严重的问题，比如检查用户登录密码时，一般数据库存储哈希运算后的 16 进制密码以防止明文泄漏。而 16 进制数有 latexmath:[\frac{1}{256}] 的概率以 `0e` 开头，同时以 `00e`、`000e` 开头的同样也会被以同样的方式处理，因此给定 `N` 位长的字符串，PHP 会有 latexmath:[\displaystyle\sum_{i=2}^n \frac{1}{16^n}] 的概率认为其等于 0。


这两类由类型带来的问题是高级语言需要尽力避免的。

在运行过程中不可能出现类型错误问题的，是强类型系统；而如果这门语言在运行过程中会因为类型错误而产生不可知的任意行为的，那么就是弱类型系统。

在编译期（运行程序前）检查类型错误的是静态类型系统，在运行过程中拒绝类型错误的程序继续运行的，则是动态类型系统。

虽然 Ruby 考虑在未来的 3.0 版本中引入静态类型检查系统，目前的 Ruby 2.7 仍是运行时的动态类型检查。但是 Ruby 是强类型语言，会在运行通过抛出类型错误，来避免错误的类型转换带来潜在的风险。
